{"version":3,"file":"dapp-interface.js","mappings":"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","sources":["webpack:///../../../node_modules/.pnpm/@sentry+webpack-plugin@1.20.0/node_modules/@sentry/webpack-plugin/src/sentry-webpack.module.js","webpack:///../../../node_modules/.pnpm/base-x@4.0.0/node_modules/base-x/src/index.js","webpack:///../../../node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///../../../node_modules/.pnpm/@wallet-standard+wallet@1.0.1/node_modules/@wallet-standard/wallet/lib/esm/register.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js","webpack:///../../../node_modules/.pnpm/tslib@2.6.0/node_modules/tslib/tslib.es6.mjs","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isFunction.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscription.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/config.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/noop.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/errorContext.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscriber.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/observable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/identity.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Observable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/pipe.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isPromise.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isIterable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/lift.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/filter.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/share.js","webpack:///./shared/messaging/WindowMessageStream.ts","webpack:///./shared/messaging/messages/payloads/permissions/PermissionType.ts","webpack:///./shared/api-env.ts","webpack:///./shared/messaging/messages/payloads/BasePayload.ts","webpack:///../../../sdk/bcs/src/b58.ts","webpack:///../../../sdk/bcs/src/b64.ts","webpack:///../../../sdk/bcs/src/hex.ts","webpack:///../../../sdk/bcs/src/uleb.ts","webpack:///../../../sdk/bcs/src/reader.ts","webpack:///../../../sdk/bcs/src/writer.ts","webpack:///../../../sdk/bcs/src/utils.ts","webpack:///../../../sdk/bcs/src/bcs-type.ts","webpack:///../../../sdk/bcs/src/bcs.ts","webpack:///../../../sdk/typescript/src/utils/sui-types.ts","webpack:///../../../sdk/typescript/src/bcs/type-tag-serializer.ts","webpack:///../../../sdk/typescript/src/bcs/bcs.ts","webpack:///../../../sdk/typescript/src/bcs/effects.ts","webpack:///../../../sdk/typescript/src/bcs/index.ts","webpack:///../../../node_modules/.pnpm/valibot@0.25.0/node_modules/valibot/dist/index.js","webpack:///../../../sdk/typescript/src/transactions/data/internal.ts","webpack:///../../../sdk/typescript/src/utils/constants.ts","webpack:///../../../sdk/typescript/src/transactions/Transaction.ts","webpack:///../../../sdk/wallet-standard/src/chains.ts","webpack:///../../../node_modules/.pnpm/@wallet-standard+wallet@1.0.1/node_modules/@wallet-standard/wallet/lib/esm/util.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/empty.js","webpack:///./dapp-interface/utils.ts","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/take.js","webpack:///./shared/messaging/messages/payloads/ErrorPayload.ts","webpack:///./dapp-interface/WalletStandardInterface.ts","webpack:///./shared/messaging/messages/Message.ts","webpack:///./dapp-interface/index.ts","webpack:///../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs","webpack:///./shared/messaging/messages/payloads/QredoConnect.ts","webpack:///./shared/messaging/messages/payloads/wallet-status-change/index.ts"],"sourcesContent":["var _global = (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}); _global.SENTRY_RELEASE={id:\"24.6.27.0\"};\n      _global.SENTRY_RELEASES=_global.SENTRY_RELEASES || {};\n      _global.SENTRY_RELEASES[\"wallet@mysten-labs\"]={id:\"24.6.27.0\"};\n      ","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RegisterWalletEvent_detail;\n/**\n * Register a {@link \"@wallet-standard/base\".Wallet} as a Standard Wallet with the app.\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to notify the app that the Wallet is\n * ready to be registered.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowAppReadyEvent} to listen for a notification from\n * the app that the app is ready to register the Wallet.\n *\n * This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon\n * as the app is ready whether the Wallet loads before or after the app.\n *\n * @param wallet Wallet to register.\n *\n * @group Wallet\n */\nexport function registerWallet(wallet) {\n    const callback = ({ register }) => register(wallet);\n    try {\n        window.dispatchEvent(new RegisterWalletEvent(callback));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event could not be dispatched\\n', error);\n    }\n    try {\n        window.addEventListener('wallet-standard:app-ready', ({ detail: api }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event listener could not be added\\n', error);\n    }\n}\nclass RegisterWalletEvent extends Event {\n    constructor(callback) {\n        super('wallet-standard:register-wallet', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _RegisterWalletEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _RegisterWalletEvent_detail, callback, \"f\");\n    }\n    get detail() {\n        return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:register-wallet';\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_RegisterWalletEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link registerWallet} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_registerWallet(wallet) {\n    var _a;\n    registerWallet(wallet);\n    try {\n        ((_a = window.navigator).wallets || (_a.wallets = [])).push(({ register }) => register(wallet));\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be pushed\\n', error);\n    }\n}\n//# sourceMappingURL=register.js.map","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","export var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map","export function isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map","export function createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map","import { createErrorClass } from './createErrorClass';\nexport var UnsubscriptionError = createErrorClass(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map","export function arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map","import { __read, __spreadArray, __values } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof UnsubscriptionError) {\n                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\nexport { Subscription };\nexport var EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export var config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map","import { __read, __spreadArray } from \"tslib\";\nexport var timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(function () {\n        var onUnhandledError = config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map","export function noop() { }\n//# sourceMappingURL=noop.js.map","export var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map","import { config } from '../config';\nvar context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map","import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = config.onStoppedNotification;\n    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nexport var EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n//# sourceMappingURL=Subscriber.js.map","export var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map","export function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map","import { identity } from './identity';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport var iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map","import { __asyncValues, __awaiter, __generator, __values } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable(function (subscriber) {\n        var obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable(function (subscriber) {\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable(function (subscriber) {\n        promise\n            .then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable(function (subscriber) {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var value = iterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable(function (subscriber) {\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var value, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 5, 6, 11]);\n                    asyncIterable_1 = __asyncValues(asyncIterable);\n                    _b.label = 1;\n                case 1: return [4, asyncIterable_1.next()];\n                case 2:\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n                    value = asyncIterable_1_1.value;\n                    subscriber.next(value);\n                    if (subscriber.closed) {\n                        return [2];\n                    }\n                    _b.label = 3;\n                case 3: return [3, 1];\n                case 4: return [3, 11];\n                case 5:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3, 11];\n                case 6:\n                    _b.trys.push([6, , 9, 10]);\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n                    return [4, _a.call(asyncIterable_1)];\n                case 7:\n                    _b.sent();\n                    _b.label = 8;\n                case 8: return [3, 10];\n                case 9:\n                    if (e_2) throw e_2.error;\n                    return [7];\n                case 10: return [7];\n                case 11:\n                    subscriber.complete();\n                    return [2];\n            }\n        });\n    });\n}\n//# sourceMappingURL=innerFrom.js.map","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n//# sourceMappingURL=isInteropObservable.js.map","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n//# sourceMappingURL=isPromise.js.map","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n//# sourceMappingURL=isAsyncIterable.js.map","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n//# sourceMappingURL=isIterable.js.map","import { __asyncGenerator, __await, __generator } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\n        var reader, _a, value, done;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = readableStream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3, 8];\n                    return [4, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    if (!done) return [3, 5];\n                    return [4, __await(void 0)];\n                case 4: return [2, _b.sent()];\n                case 5: return [4, __await(value)];\n                case 6: return [4, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3, 2];\n                case 8: return [3, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7];\n                case 10: return [2];\n            }\n        });\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n//# sourceMappingURL=isReadableStreamLike.js.map","export function createInvalidObservableTypeError(input) {\n    return new TypeError(\"You provided \" + (input !== null && typeof input === 'object' ? 'an invalid object' : \"'\" + input + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\n//# sourceMappingURL=throwUnobservableError.js.map","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return function (source) {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n//# sourceMappingURL=lift.js.map","import { __extends } from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = (function (_super) {\n    __extends(OperatorSubscriber, _super);\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        var _this = _super.call(this, destination) || this;\n        _this.onFinalize = onFinalize;\n        _this.shouldUnsubscribe = shouldUnsubscribe;\n        _this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : _super.prototype._next;\n        _this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._error;\n        _this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._complete;\n        return _this;\n    }\n    OperatorSubscriber.prototype.unsubscribe = function () {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            var closed_1 = this.closed;\n            _super.prototype.unsubscribe.call(this);\n            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    };\n    return OperatorSubscriber;\n}(Subscriber));\nexport { OperatorSubscriber };\n//# sourceMappingURL=OperatorSubscriber.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if (isFunction(resultSelector)) {\n        return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });\n}\n//# sourceMappingURL=mergeMap.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function () {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };\n    var doInnerSub = function (value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, function () {\n            innerComplete = true;\n        }, undefined, function () {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function () {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while (buffer.length && active < concurrent) {\n                        _loop_1();\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function () {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { map } from \"../operators/map\";\nvar isArray = Array.isArray;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(function (args) { return callOrApply(fn, args); });\n}\n//# sourceMappingURL=mapOneOrManyArgs.js.map","import { __read } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nvar nodeEventEmitterMethods = ['addListener', 'removeListener'];\nvar eventTargetMethods = ['addEventListener', 'removeEventListener'];\nvar jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    var _a = __read(isEventTarget(target)\n        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [], 2), add = _a[0], remove = _a[1];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable(function (subscriber) {\n        var handler = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return subscriber.next(1 < args.length ? args : args[0]);\n        };\n        add(handler);\n        return function () { return remove(handler); };\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n//# sourceMappingURL=fromEvent.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\n    });\n}\n//# sourceMappingURL=filter.js.map","import { createErrorClass } from './createErrorClass';\nexport var ObjectUnsubscribedError = createErrorClass(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map","import { __extends, __values } from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        errorContext(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(function () {\n            _this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\n    return function (wrapperSource) {\n        var connection;\n        var resetConnection;\n        var subject;\n        var refCount = 0;\n        var hasCompleted = false;\n        var hasErrored = false;\n        var cancelReset = function () {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        var reset = function () {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        var resetAndUnsubscribe = function () {\n            var conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return operate(function (source, subscriber) {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(function () {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new SafeSubscriber({\n                    next: function (value) { return dest.next(value); },\n                    error: function (err) {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: function () {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    var onSubscriber = new SafeSubscriber({\n        next: function () {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Message } from '_messages';\nimport { filter, fromEvent, map, share } from 'rxjs';\nimport type { Observable } from 'rxjs';\n\nexport type ClientType = 'sui_in-page' | 'sui_content-script';\n\ntype WindowMessage = {\n\ttarget: ClientType;\n\tpayload: Message;\n};\n\nexport class WindowMessageStream {\n\tpublic readonly messages: Observable<Message>;\n\tprivate _name: ClientType;\n\tprivate _target: ClientType;\n\n\tconstructor(name: ClientType, target: ClientType) {\n\t\tif (name === target) {\n\t\t\tthrow new Error('[WindowMessageStream] name and target must be different');\n\t\t}\n\t\tthis._name = name;\n\t\tthis._target = target;\n\t\tthis.messages = fromEvent<MessageEvent<WindowMessage>>(window, 'message').pipe(\n\t\t\tfilter((message) => message.source === window && message.data.target === this._name),\n\t\t\tmap((message) => message.data.payload),\n\t\t\tshare(),\n\t\t);\n\t}\n\n\tpublic send(payload: Message) {\n\t\tconst msg: WindowMessage = {\n\t\t\ttarget: this._target,\n\t\t\tpayload,\n\t\t};\n\t\twindow.postMessage(msg);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport const ALL_PERMISSION_TYPES = ['viewAccount', 'suggestTransactions'] as const;\ntype AllPermissionsType = typeof ALL_PERMISSION_TYPES;\nexport type PermissionType = AllPermissionsType[number];\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function isValidPermissionTypes(types: any): types is PermissionType[] {\n\treturn (\n\t\tArray.isArray(types) &&\n\t\t!!types.length &&\n\t\ttypes.every((aType) => ALL_PERMISSION_TYPES.includes(aType))\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum API_ENV {\n\tmainnet = 'mainnet',\n\tdevNet = 'devNet',\n\ttestNet = 'testNet',\n\tlocal = 'local',\n\tcustomRPC = 'customRPC',\n}\n\nexport const networkNames: Record<API_ENV, string> = {\n\t[API_ENV.local]: 'Local',\n\t[API_ENV.testNet]: 'Testnet',\n\t[API_ENV.devNet]: 'Devnet',\n\t[API_ENV.mainnet]: 'Mainnet',\n\t[API_ENV.customRPC]: 'Custom RPC',\n};\n\nexport type NetworkEnvType =\n\t| { env: Exclude<API_ENV, API_ENV.customRPC>; customRpcUrl: null }\n\t| { env: API_ENV.customRPC; customRpcUrl: string };\n\nexport const ENV_TO_API: Record<API_ENV, string | null> = {\n\t[API_ENV.customRPC]: null,\n\t[API_ENV.local]: process.env.API_ENDPOINT_LOCAL_FULLNODE || '',\n\t[API_ENV.devNet]: process.env.API_ENDPOINT_DEV_NET_FULLNODE || '',\n\t[API_ENV.testNet]: process.env.API_ENDPOINT_TEST_NET_FULLNODE || '',\n\t[API_ENV.mainnet]: process.env.API_ENDPOINT_MAINNET_FULLNODE || '',\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Payload } from './Payload';\n\nexport type PayloadType =\n\t| 'permission-request'\n\t| 'permission-response'\n\t| 'get-permission-requests'\n\t| 'get-account'\n\t| 'get-account-response'\n\t| 'has-permissions-request'\n\t| 'has-permissions-response'\n\t| 'acquire-permissions-request'\n\t| 'acquire-permissions-response'\n\t| 'execute-transaction-request'\n\t| 'execute-transaction-response'\n\t| 'sign-transaction-request'\n\t| 'sign-transaction-response'\n\t| 'get-transaction-requests'\n\t| 'get-transaction-requests-response'\n\t| 'transaction-request-response'\n\t| 'update-active-origin'\n\t| 'disconnect-app'\n\t| 'done'\n\t| 'keyring'\n\t| 'wallet-status-changed'\n\t| 'get-features'\n\t| 'features-response'\n\t| 'get-network'\n\t| 'set-network'\n\t| 'sign-message-request'\n\t| 'qredo-connect'\n\t| 'method-payload';\n\nexport interface BasePayload {\n\ttype: PayloadType;\n}\n\nexport function isBasePayload(payload: Payload): payload is BasePayload {\n\treturn 'type' in payload && typeof payload.type !== 'undefined';\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromB64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toB64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHEX(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromB58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromB64(b64));\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input(value));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: name,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromB58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t  )\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromB58, fromB64, fromHEX, toB58, toB64, toHEX } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHEX(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromB58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\t\t\toutput: (val) => toB64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\t\t\t\toutput: (val) => toB64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t  },\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\t\t\t\toutput: (val) => toB64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\toutput: (val) => toB64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tCommand,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\tTransactionEffects,\n};\n\nexport { suiBcs as bcs };\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/errorMessage/errorMessage.ts\nfunction errorMessage(message) {\n  return typeof message === \"function\" ? message() : message;\n}\n\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(validation, message, input, requirement, path) {\n  return {\n    issues: [\n      {\n        validation,\n        message: errorMessage(message),\n        input,\n        requirement,\n        path\n      }\n    ]\n  };\n}\n\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n  return { output };\n}\n\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/parseResult/parseResult.ts\nfunction parseResult(typed, output, issues) {\n  return { typed, output, issues };\n}\n\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = defaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = defaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    requirement: issue?.requirement,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/pipeResult/utils/pipeInfo/pipeInfo.ts\nfunction pipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(input, pipe, parseInfo, reason, issues) {\n  let info;\n  let output = input;\n  if (pipe?.length && !parseInfo?.skipPipe) {\n    for (const action of pipe) {\n      const result = action._parse(output);\n      if (result.issues) {\n        info = info || pipeInfo(parseInfo, reason);\n        for (const issueInfo of result.issues) {\n          const issue = pipeIssue(info, issueInfo);\n          issues ? issues.push(issue) : issues = [issue];\n        }\n        if (info.abortEarly || info.abortPipeEarly) {\n          break;\n        }\n      } else {\n        output = result.output;\n      }\n    }\n  }\n  return parseResult(true, output, issues);\n}\n\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(input, pipe, parseInfo, reason, issues) {\n  let info;\n  let output = input;\n  if (pipe?.length && !parseInfo?.skipPipe) {\n    for (const action of pipe) {\n      const result = await action._parse(output);\n      if (result.issues) {\n        info = info || pipeInfo(parseInfo, reason);\n        for (const issueInfo of result.issues) {\n          const issue = pipeIssue(info, issueInfo);\n          issues ? issues.push(issue) : issues = [issue];\n        }\n        if (info.abortEarly || info.abortPipeEarly) {\n          break;\n        }\n      } else {\n        output = result.output;\n      }\n    }\n  }\n  return parseResult(true, output, issues);\n}\n\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(info, reason, validation, message, input, path, issues) {\n  return {\n    typed: false,\n    output: input,\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: errorMessage(message),\n        input,\n        path,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return result.issues ? parseResult(true, getFallback(this, { input, issues: result.issues })) : result;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return result.issues ? parseResult(\n        true,\n        await getFallbackAsync(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n  return {\n    ...validation,\n    _parse(input) {\n      const result = validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input, info) {\n  return !schema._parse(input, {\n    abortEarly: true,\n    skipPipe: info?.skipPipe\n  }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return pipeResult(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return pipeResultAsync(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return schemaIssue(info, \"type\", \"array\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = this.item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output.push(result.output);\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"array\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return schemaIssue(info, \"type\", \"array\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  typed = false;\n                  throw null;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output[key] = result.output;\n            }\n          }\n        })\n      ).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"array\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return schemaIssue(info, \"type\", \"bigint\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return schemaIssue(info, \"type\", \"bigint\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return schemaIssue(info, \"type\", \"blob\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return schemaIssue(info, \"type\", \"blob\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return schemaIssue(info, \"type\", \"boolean\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return schemaIssue(info, \"type\", \"boolean\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return schemaIssue(info, \"type\", \"date\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return schemaIssue(info, \"type\", \"date\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: false,\n    enum: enum_2,\n    message,\n    _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return schemaIssue(info, \"type\", \"enum\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return schemaIssue(info, \"type\", \"enum\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return schemaIssue(info, \"type\", \"instance\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return schemaIssue(info, \"type\", \"instance\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return { output: output1 };\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return { output: array2 };\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return { output: object2 };\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        outputs.push(result.output);\n      }\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(info, \"type\", \"intersect\", this.message, input);\n          }\n          output = result.output;\n        }\n        return pipeResult(output, this.pipe, info, \"intersect\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: false,\n    literal: literal2,\n    message,\n    _parse(input, info) {\n      if (input !== this.literal) {\n        return schemaIssue(info, \"type\", \"literal\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, info) {\n      if (input !== this.literal) {\n        return schemaIssue(info, \"type\", \"literal\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return schemaIssue(info, \"type\", \"map\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = this.key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        const valueResult = this.value._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!keyResult.typed || !valueResult.typed) {\n          typed = false;\n        }\n        output.set(keyResult.output, valueResult.output);\n      }\n      if (typed) {\n        return pipeResult(output, this.pipe, info, \"map\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return schemaIssue(info, \"type\", \"map\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: this.key, value: inputKey, origin: \"key\" },\n              { schema: this.value, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  }\n                  return result;\n                }\n              }\n            })\n          ).catch(() => []);\n          if (!keyResult?.typed || !valueResult?.typed) {\n            typed = false;\n          }\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      if (typed) {\n        return pipeResultAsync(output, this.pipe, info, \"map\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return schemaIssue(info, \"type\", \"nan\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return schemaIssue(info, \"type\", \"nan\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: false,\n    message,\n    _parse(input, info) {\n      return schemaIssue(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      return schemaIssue(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null) {\n        return schemaIssue(info, \"type\", \"non_nullable\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null) {\n        return schemaIssue(info, \"type\", \"non_nullable\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return schemaIssue(info, \"type\", \"non_nullish\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return schemaIssue(info, \"type\", \"non_nullish\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === void 0) {\n        return schemaIssue(info, \"type\", \"non_optional\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === void 0) {\n        return schemaIssue(info, \"type\", \"non_optional\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (input !== null) {\n        return schemaIssue(info, \"type\", \"null\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (input !== null) {\n        return schemaIssue(info, \"type\", \"null\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return schemaIssue(info, \"type\", \"number\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return schemaIssue(info, \"type\", \"number\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let typed = true;\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in this.entries)) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!result.typed) {\n              typed = false;\n            }\n            output[key] = result.output;\n          }\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"object\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let typed = true;\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        this.rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in this.entries)) {\n                const result = await this.rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"object\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return schemaIssue(info, \"type\", \"picklist\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return schemaIssue(info, \"type\", \"picklist\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return schemaIssue(info, \"type\", \"string\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return schemaIssue(info, \"type\", \"string\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = defaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = defaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"record\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!keyResult.typed || !valueResult.typed) {\n            typed = false;\n          }\n          if (keyResult.typed) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"record\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"record\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    }\n                    return result;\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (!keyResult?.typed || !valueResult?.typed) {\n              typed = false;\n            }\n            if (keyResult?.typed && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"record\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    type: \"recursive\",\n    async: false,\n    getter,\n    _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    type: \"recursive\",\n    async: true,\n    getter,\n    async _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return schemaIssue(info, \"type\", \"set\", this.message, input);\n      }\n      let key = 0;\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = this.value._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output.add(result.output);\n        key++;\n      }\n      if (typed) {\n        return pipeResult(output, this.pipe, info, \"set\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return schemaIssue(info, \"type\", \"set\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.value._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  typed = false;\n                  throw null;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output.add(result.output);\n            }\n          }\n        })\n      ).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(output, this.pipe, info, \"set\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!this.check(input)) {\n        return schemaIssue(info, \"type\", \"special\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!await this.check(input)) {\n        return schemaIssue(info, \"type\", \"special\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return schemaIssue(info, \"type\", \"symbol\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return schemaIssue(info, \"type\", \"symbol\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return schemaIssue(info, \"type\", \"tuple\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      for (let key = 0; key < this.items.length; key++) {\n        const value2 = input[key];\n        const result = this.items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output[key] = result.output;\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (let key = this.items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output[key] = result.output;\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"tuple\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return schemaIssue(info, \"type\", \"tuple\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          this.items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        this.rest && Promise.all(\n          input.slice(this.items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = this.items.length + index;\n              const result = await this.rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"tuple\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"undefined\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"undefined\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      if (output) {\n        return pipeResult(output[0], this.pipe, info, \"union\");\n      }\n      return schemaIssue(\n        info,\n        \"type\",\n        \"union\",\n        this.message,\n        input,\n        void 0,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      if (output) {\n        return pipeResultAsync(output[0], this.pipe, info, \"union\");\n      }\n      return schemaIssue(\n        info,\n        \"type\",\n        \"union\",\n        this.message,\n        input,\n        void 0,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return pipeResult(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return pipeResultAsync(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"variant\",\n    async: false,\n    key,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"variant\", this.message, input);\n      }\n      if (this.key in input) {\n        let issues;\n        let output;\n        const parseOptions = (options2) => {\n          for (const schema of options2) {\n            if (schema.type === \"object\") {\n              const keyResult = schema.entries[this.key]._parse(\n                input[this.key],\n                info\n              );\n              if (!keyResult.issues) {\n                const dataResult = schema._parse(input, info);\n                if (dataResult.issues) {\n                  issues = dataResult.issues;\n                } else {\n                  output = [dataResult.output];\n                  break;\n                }\n              }\n            } else if (schema.type === \"variant\") {\n              parseOptions(schema.options);\n              if (output) {\n                break;\n              }\n            }\n          }\n        };\n        parseOptions(this.options);\n        if (output) {\n          return pipeResult(output[0], this.pipe, info, \"variant\");\n        }\n        if (issues) {\n          return parseResult(false, output, issues);\n        }\n      }\n      return schemaIssue(info, \"type\", \"variant\", this.message, input, [\n        {\n          type: \"object\",\n          input,\n          key: this.key,\n          value: void 0\n        }\n      ]);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"variant\",\n    async: true,\n    key,\n    options,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"variant\", this.message, input);\n      }\n      if (this.key in input) {\n        let issues;\n        let output;\n        const parseOptions = async (options2) => {\n          for (const schema of options2) {\n            if (schema.type === \"object\") {\n              const keyResult = await schema.entries[this.key]._parse(\n                input[this.key],\n                info\n              );\n              if (!keyResult.issues) {\n                const dataResult = await schema._parse(input, info);\n                if (dataResult.issues) {\n                  issues = dataResult.issues;\n                } else {\n                  output = [dataResult.output];\n                  break;\n                }\n              }\n            } else if (schema.type === \"variant\") {\n              await parseOptions(schema.options);\n              if (output) {\n                break;\n              }\n            }\n          }\n        };\n        await parseOptions(this.options);\n        if (output) {\n          return pipeResultAsync(output[0], this.pipe, info, \"variant\");\n        }\n        if (issues) {\n          return parseResult(false, output, issues);\n        }\n      }\n      return schemaIssue(info, \"type\", \"variant\", this.message, input, [\n        {\n          type: \"object\",\n          input,\n          key: this.key,\n          value: void 0\n        }\n      ]);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"void\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"void\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    message,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        cachedKeys = cachedKeys || Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        cachedKeys = cachedKeys || Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        result.output = action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResult(result.output, arg1, info, typeof result.output);\n        }\n        return arg1._parse(result.output, info);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        result.output = await action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResultAsync(\n            result.output,\n            arg1,\n            info,\n            typeof result.output\n          );\n        }\n        return arg1._parse(result.output, info);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return actionOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return actionOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bic/bic.ts\nfunction bic(message = \"Invalid BIC\") {\n  return {\n    type: \"bic\",\n    async: false,\n    message,\n    requirement: BIC_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input.toUpperCase()) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(6[27]\\d{14}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message = \"Invalid credit card\") {\n  return {\n    type: \"credit_card\",\n    async: false,\n    message,\n    requirement: (input) => {\n      const sanitized = input.replace(SANITIZE_REGEX, \"\");\n      return PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n    },\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message = \"Invalid Cuid2\") {\n  return {\n    type: \"cuid2\",\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      return !await this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/decimal/decimal.ts\nfunction decimal(message = \"Invalid decimal\") {\n  return {\n    type: \"decimal\",\n    async: false,\n    message,\n    requirement: DECIMAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message = \"Invalid email\") {\n  return {\n    type: \"email\",\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message = \"Invalid emoji\") {\n  return {\n    type: \"emoji\",\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message = \"Invalid end\") {\n  return {\n    type: \"ends_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.endsWith(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message = \"Invalid input\") {\n  return {\n    type: \"equal\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"excludes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.includes(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message = \"Invalid finite number\") {\n  return {\n    type: \"finite\",\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message = \"Invalid hexadecimal\") {\n  return {\n    type: \"hexadecimal\",\n    async: false,\n    message,\n    requirement: HEXADECIMAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message = \"Invalid hex color\") {\n  return {\n    type: \"hex_color\",\n    async: false,\n    message,\n    requirement: HEX_COLOR_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message = \"Invalid IMEI\") {\n  return {\n    type: \"imei\",\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      return !this.requirement[0].test(input) || !this.requirement[1](input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"includes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.includes(requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message = \"Invalid integer\") {\n  return {\n    type: \"integer\",\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message = \"Invalid IP\") {\n  return {\n    type: \"ip\",\n    async: false,\n    message,\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message = \"Invalid IPv4\") {\n  return {\n    type: \"ipv4\",\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message = \"Invalid IPv6\") {\n  return {\n    type: \"ipv6\",\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message = \"Invalid date\") {\n  return {\n    type: \"iso_date\",\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message = \"Invalid date-time\") {\n  return {\n    type: \"iso_date_time\",\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message = \"Invalid time\") {\n  return {\n    type: \"iso_time\",\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message = \"Invalid time second\") {\n  return {\n    type: \"iso_time_second\",\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message = \"Invalid timestamp\") {\n  return {\n    type: \"iso_timestamp\",\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message = \"Invalid week\") {\n  return {\n    type: \"iso_week\",\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message = \"Invalid length\") {\n  return {\n    type: \"length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac/mac.ts\nfunction mac(message = \"Invalid MAC\") {\n  return {\n    type: \"mac\",\n    async: false,\n    message,\n    requirement: [MAC48_REGEX, MAC64_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac48/mac48.ts\nfunction mac48(message = \"Invalid 48 bit MAC\") {\n  return {\n    type: \"mac48\",\n    async: false,\n    message,\n    requirement: MAC48_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac64/mac64.ts\nfunction mac64(message = \"Invalid 64 bit MAC\") {\n  return {\n    type: \"mac64\",\n    async: false,\n    message,\n    requirement: MAC64_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"max_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"max_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"max_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"max_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"min_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message = \"Invalid MIME type\") {\n  return {\n    type: \"mime_type\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.includes(input.type) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"min_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"min_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"min_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message = \"Invalid multiple\") {\n  return {\n    type: \"multiple_of\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input % this.requirement !== 0 ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"not_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"not_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"not_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"not_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/octal/octal.ts\nfunction octal(message = \"Invalid octal\") {\n  return {\n    type: \"octal\",\n    async: false,\n    message,\n    requirement: OCTAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message = \"Invalid regex\") {\n  return {\n    type: \"regex\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message = \"Invalid safe integer\") {\n  return {\n    type: \"safe_integer\",\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message = \"Invalid size\") {\n  return {\n    type: \"size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message = \"Invalid start\") {\n  return {\n    type: \"stars_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.startsWith(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message = \"Invalid ULID\") {\n  return {\n    type: \"ulid\",\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message = \"Invalid URL\") {\n  return {\n    type: \"url\",\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message = \"Invalid UUID\") {\n  return {\n    type: \"uuid\",\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message = \"Invalid value\") {\n  return {\n    type: \"value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\nexport {\n  BIC_REGEX,\n  BrandSymbol,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  actionIssue,\n  actionOutput,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  decimal,\n  defaultArgs,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  getDefault,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  octal,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parseResult,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  pipeResult,\n  pipeResultAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  restAndDefaultArgs,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  schemaIssue,\n  set,\n  setAsync,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { BaseSchema, Input, Output } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcustom,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\trecord,\n\trecursive,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\ntype EnumSchema<T extends Record<string, BaseSchema<any>>> = BaseSchema<\n\tEnumInputShape<\n\t\tMerge<{\n\t\t\t[K in keyof T]: Input<T[K]>;\n\t\t}>\n\t>,\n\tEnumOutputShape<\n\t\tMerge<{\n\t\t\t[K in keyof T]: Output<T[K]>;\n\t\t}>\n\t>\n>;\n\nexport function safeEnum<T extends Record<string, BaseSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn transform(union(unionOptions), (value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})) as EnumSchema<T>;\n}\n\nexport const SuiAddress = transform(string(), (value) => normalizeSuiAddress(value), [\n\tcustom(isValidSuiAddress),\n]);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = union(\n\t[string(), number([integer()])],\n\t[\n\t\tcustom((val) => {\n\t\t\ttry {\n\t\t\t\tBigInt(val);\n\t\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}, 'Invalid u64'),\n\t],\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = Output<typeof ObjectRef>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const Argument = transform(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: number([integer()]), type: optional(literal('pure')) }),\n\t\tobject({ Input: number([integer()]), type: optional(literal('object')) }),\n\t\tobject({ Result: number([integer()]) }),\n\t\tobject({ NestedResult: tuple([number([integer()]), number([integer()])]) }),\n\t]),\n\t(value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t}),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as BaseSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = Output<typeof Argument>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\nexport type GasData = Output<typeof GasData>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = Output<typeof StructTag>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: BaseSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: recursive(() => OpenMoveTypeSignatureBody) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(recursive(() => OpenMoveTypeSignatureBody)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: number([integer()]) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = Output<typeof OpenMoveTypeSignature>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = Output<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\nexport type CallArg = Output<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = Output<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n});\nexport type TransactionData = Output<typeof TransactionData>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport type { Input } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<Input<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<Input<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n\tconst baseResult = { $kind: 'Result' as const, Result: index };\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tNestedResult: [index, resultIndex],\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[] = [];\n\t#buildPlugins: TransactionPlugin[] = [];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromB64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\treturn newTransaction;\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: Input<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#data.addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#data.addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tthis.#data = new TransactionDataBuilder();\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } {\n\t\tif (typeof value === 'function') {\n\t\t\treturn this.object(value(this));\n\t\t}\n\n\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\n\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t// Upgrade shared object inputs to mutable if needed:\n\t\tif (inserted?.Object?.SharedObject && typeof value === 'object' && value.Object?.SharedObject) {\n\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t}\n\n\t\treturn inserted\n\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t: this.#data.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: value,\n\t\t\t  );\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction */\n\tadd<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n\t\tif (typeof command === 'function') {\n\t\t\treturn command(this);\n\t\t}\n\n\t\tconst index = this.#data.commands.push(command);\n\n\t\treturn createTransactionResult(index - 1) as T;\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\treturn parse(Argument, arg(this));\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\treturn JSON.stringify(\n\t\t\tparse(SerializedTransactionDataV2, this.#data.snapshot()),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IdentifierString } from '@wallet-standard/core';\n\n/** Sui Devnet */\nexport const SUI_DEVNET_CHAIN = 'sui:devnet';\n\n/** Sui Testnet */\nexport const SUI_TESTNET_CHAIN = 'sui:testnet';\n\n/** Sui Localnet */\nexport const SUI_LOCALNET_CHAIN = 'sui:localnet';\n\n/** Sui Mainnet */\nexport const SUI_MAINNET_CHAIN = 'sui:mainnet';\n\nexport const SUI_CHAINS = [\n\tSUI_DEVNET_CHAIN,\n\tSUI_TESTNET_CHAIN,\n\tSUI_LOCALNET_CHAIN,\n\tSUI_MAINNET_CHAIN,\n] as const;\n\nexport type SuiChain =\n\t| typeof SUI_DEVNET_CHAIN\n\t| typeof SUI_TESTNET_CHAIN\n\t| typeof SUI_LOCALNET_CHAIN\n\t| typeof SUI_MAINNET_CHAIN;\n\n/**\n * Utility that returns whether or not a chain identifier is a valid Sui chain.\n * @param chain a chain identifier in the form of `${string}:{$string}`\n */\nexport function isSuiChain(chain: IdentifierString): chain is SuiChain {\n\treturn SUI_CHAINS.includes(chain as SuiChain);\n}\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nexport class ReadonlyWalletAccount {\n    /**\n     * Create and freeze a read-only account.\n     *\n     * @param account Account to copy properties from.\n     */\n    constructor(account) {\n        _ReadonlyWalletAccount_address.set(this, void 0);\n        _ReadonlyWalletAccount_publicKey.set(this, void 0);\n        _ReadonlyWalletAccount_chains.set(this, void 0);\n        _ReadonlyWalletAccount_features.set(this, void 0);\n        _ReadonlyWalletAccount_label.set(this, void 0);\n        _ReadonlyWalletAccount_icon.set(this, void 0);\n        if (new.target === ReadonlyWalletAccount) {\n            Object.freeze(this);\n        }\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n    get address() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n    get publicKey() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n    get chains() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n    get features() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n    get label() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n    get icon() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, \"f\");\n    }\n}\n_ReadonlyWalletAccount_address = new WeakMap(), _ReadonlyWalletAccount_publicKey = new WeakMap(), _ReadonlyWalletAccount_chains = new WeakMap(), _ReadonlyWalletAccount_features = new WeakMap(), _ReadonlyWalletAccount_label = new WeakMap(), _ReadonlyWalletAccount_icon = new WeakMap();\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nexport function arraysEqual(a, b) {\n    if (a === b)\n        return true;\n    const length = a.length;\n    if (length !== b.length)\n        return false;\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nexport function bytesEqual(a, b) {\n    return arraysEqual(a, b);\n}\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nexport function concatBytes(first, ...others) {\n    const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n    const bytes = new Uint8Array(length);\n    bytes.set(first, 0);\n    for (const other of others) {\n        bytes.set(other, bytes.length);\n    }\n    return bytes;\n}\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nexport function pick(source, ...keys) {\n    const picked = {};\n    for (const key of keys) {\n        picked[key] = source[key];\n    }\n    return picked;\n}\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nexport function guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n//# sourceMappingURL=util.js.map","import { createErrorClass } from './createErrorClass';\nexport var EmptyError = createErrorClass(function (_super) { return function EmptyErrorImpl() {\n    _super(this);\n    this.name = 'EmptyError';\n    this.message = 'no elements in sequence';\n}; });\n//# sourceMappingURL=EmptyError.js.map","import { Observable } from '../Observable';\nexport var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isErrorPayload, type Payload } from '_payloads';\nimport { lastValueFrom, map, take, type Observable } from 'rxjs';\n\nexport function mapToPromise<T extends Payload | void, R>(\n\tstream: Observable<T>,\n\tproject: (value: T) => R,\n) {\n\treturn lastValueFrom(\n\t\tstream.pipe(\n\t\t\ttake<T>(1),\n\t\t\tmap<T, R>((response) => {\n\t\t\t\tif (response && isErrorPayload(response)) {\n\t\t\t\t\t// TODO: throw proper error\n\t\t\t\t\tthrow new Error(response.message);\n\t\t\t\t}\n\t\t\t\treturn project(response);\n\t\t\t}),\n\t\t),\n\t);\n}\n","import { EmptyError } from './util/EmptyError';\nexport function lastValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var _hasValue = false;\n        var _value;\n        source.subscribe({\n            next: function (value) {\n                _value = value;\n                _hasValue = true;\n            },\n            error: reject,\n            complete: function () {\n                if (_hasValue) {\n                    resolve(_value);\n                }\n                else if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError());\n                }\n            },\n        });\n    });\n}\n//# sourceMappingURL=lastValueFrom.js.map","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            function () { return EMPTY; }\n        : operate(function (source, subscriber) {\n            var seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n//# sourceMappingURL=take.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Payload } from './Payload';\n\nexport interface ErrorPayload {\n\terror: true;\n\tcode: number;\n\tmessage: string;\n}\n\nexport function isErrorPayload(payload: Payload): payload is ErrorPayload {\n\treturn 'error' in payload && payload.error === true;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createMessage } from '_messages';\nimport { WindowMessageStream } from '_messaging/WindowMessageStream';\nimport type { BasePayload, Payload } from '_payloads';\nimport type { GetAccount } from '_payloads/account/GetAccount';\nimport type { GetAccountResponse } from '_payloads/account/GetAccountResponse';\nimport type { SetNetworkPayload } from '_payloads/network';\nimport {\n\tALL_PERMISSION_TYPES,\n\ttype AcquirePermissionsRequest,\n\ttype AcquirePermissionsResponse,\n\ttype HasPermissionsRequest,\n\ttype HasPermissionsResponse,\n} from '_payloads/permissions';\nimport type {\n\tExecuteTransactionRequest,\n\tExecuteTransactionResponse,\n\tSignTransactionRequest,\n\tSignTransactionResponse,\n} from '_payloads/transactions';\nimport { API_ENV } from '_src/shared/api-env';\nimport type { NetworkEnvType } from '_src/shared/api-env';\nimport {\n\tisQredoConnectPayload,\n\ttype QredoConnectPayload,\n} from '_src/shared/messaging/messages/payloads/QredoConnect';\nimport { type SignMessageRequest } from '_src/shared/messaging/messages/payloads/transactions/SignMessage';\nimport { isWalletStatusChangePayload } from '_src/shared/messaging/messages/payloads/wallet-status-change';\nimport { bcs } from '@mysten/sui/bcs';\nimport { isTransaction } from '@mysten/sui/transactions';\nimport { fromB64, toB64 } from '@mysten/sui/utils';\nimport {\n\tReadonlyWalletAccount,\n\tSUI_CHAINS,\n\tSUI_DEVNET_CHAIN,\n\tSUI_LOCALNET_CHAIN,\n\tSUI_MAINNET_CHAIN,\n\tSUI_TESTNET_CHAIN,\n\ttype StandardConnectFeature,\n\ttype StandardConnectMethod,\n\ttype StandardEventsFeature,\n\ttype StandardEventsListeners,\n\ttype StandardEventsOnMethod,\n\ttype SuiFeatures,\n\ttype SuiSignAndExecuteTransactionBlockMethod,\n\ttype SuiSignAndExecuteTransactionMethod,\n\ttype SuiSignMessageMethod,\n\ttype SuiSignPersonalMessageMethod,\n\ttype SuiSignTransactionBlockMethod,\n\ttype SuiSignTransactionMethod,\n\ttype Wallet,\n} from '@mysten/wallet-standard';\nimport mitt, { type Emitter } from 'mitt';\nimport { filter, map, type Observable } from 'rxjs';\n\nimport { mapToPromise } from './utils';\n\ntype WalletEventsMap = {\n\t[E in keyof StandardEventsListeners]: Parameters<StandardEventsListeners[E]>[0];\n};\n\n// NOTE: Because this runs in a content script, we can't fetch the manifest.\nconst name = process.env.APP_NAME || 'Sui Wallet';\n\nexport type QredoConnectInput = {\n\tservice: string;\n\tapiUrl: string;\n\ttoken: string;\n} & (\n\t| {\n\t\t\t/** @deprecated renamed to workspace, please use that */\n\t\t\torganization: string;\n\t  }\n\t| {\n\t\t\tworkspace: string;\n\t  }\n);\n\ntype QredoConnectFeature = {\n\t'qredo:connect': {\n\t\tversion: '0.0.1';\n\t\tqredoConnect: (input: QredoConnectInput) => Promise<void>;\n\t};\n};\ntype ChainType = Wallet['chains'][number];\nconst API_ENV_TO_CHAIN: Record<Exclude<API_ENV, API_ENV.customRPC>, ChainType> = {\n\t[API_ENV.local]: SUI_LOCALNET_CHAIN,\n\t[API_ENV.devNet]: SUI_DEVNET_CHAIN,\n\t[API_ENV.testNet]: SUI_TESTNET_CHAIN,\n\t[API_ENV.mainnet]: SUI_MAINNET_CHAIN,\n};\n\nexport class SuiWallet implements Wallet {\n\treadonly #events: Emitter<WalletEventsMap>;\n\treadonly #version = '1.0.0' as const;\n\treadonly #name = name;\n\t#accounts: ReadonlyWalletAccount[];\n\t#messagesStream: WindowMessageStream;\n\t#activeChain: ChainType | null = null;\n\n\tget version() {\n\t\treturn this.#version;\n\t}\n\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\tget icon() {\n\t\treturn 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzIiIGhlaWdodD0iNzIiIHZpZXdCb3g9IjAgMCA3MiA3MiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjcyIiBoZWlnaHQ9IjcyIiByeD0iMTYiIGZpbGw9IiM2RkJDRjAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yMC40MjEzIDUyLjc4MzhDMjMuNjQ5NiA1OC4zNzYgMjkuNDMyMSA2MS43MTQyIDM1Ljg4ODggNjEuNzE0MkM0Mi4zNDU1IDYxLjcxNDIgNDguMTI3IDU4LjM3NiA1MS4zNTY0IDUyLjc4MzhDNTQuNTg0OCA0Ny4xOTI2IDU0LjU4NDggNDAuNTE2MyA1MS4zNTY0IDM0LjkyNEwzNy43NTI0IDExLjM2MTVDMzYuOTI0MSA5LjkyNzAxIDM0Ljg1MzUgOS45MjcwMSAzNC4wMjUzIDExLjM2MTVMMjAuNDIxMyAzNC45MjRDMTcuMTkyOSA0MC41MTUyIDE3LjE5MjkgNDcuMTkxNSAyMC40MjEzIDUyLjc4MzhaTTMyLjA1NjYgMjIuNTcxM0wzNC45NTcxIDE3LjU0NzRDMzUuMzcxMiAxNi44MzAxIDM2LjQwNjUgMTYuODMwMSAzNi44MjA2IDE3LjU0NzRMNDcuOTc5MSAzNi44NzQ4QzUwLjAyOTEgNDAuNDI1NCA1MC40MTM5IDQ0LjUzNSA0OS4xMzM1IDQ4LjI5NTRDNDkuMDAwMiA0Ny42ODE5IDQ4LjgxMzggNDcuMDU0MiA0OC41NjI2IDQ2LjQyMDFDNDcuMDIxMyA0Mi41MzA0IDQzLjUzNjMgMzkuNTI4OSAzOC4yMDIzIDM3LjQ5ODJDMzQuNTM1MSAzNi4xMDcxIDMyLjE5NDMgMzQuMDYxMyAzMS4yNDMxIDMxLjQxNzFDMzAuMDE4IDI4LjAwODkgMzEuMjk3NiAyNC4yOTI0IDMyLjA1NjYgMjIuNTcxM1pNMjcuMTEwNyAzMS4xMzc5TDIzLjc5ODYgMzYuODc0OEMyMS4yNzQ4IDQxLjI0NTkgMjEuMjc0OCA0Ni40NjQxIDIzLjc5ODYgNTAuODM1M0MyNi4zMjIzIDU1LjIwNjQgMzAuODQxMyA1Ny44MTUgMzUuODg4OCA1Ny44MTVDMzkuMjQxMyA1Ny44MTUgNDIuMzYxNSA1Ni42NjMzIDQ0LjgxODQgNTQuNjA4OEM0NS4xMzg4IDUzLjgwMjEgNDYuMTMxIDUwLjg0OTIgNDQuOTA1MiA0Ny44MDU4QzQzLjc3MyA0NC45OTU0IDQxLjA0ODIgNDIuNzUxOSAzNi44MDYxIDQxLjEzNkMzMi4wMTEgMzkuMzE3MSAyOC44OTU4IDM2LjQ3NzQgMjcuNTQ4NiAzMi42OTg0QzI3LjM2MzEgMzIuMTc4MSAyNy4yMTg5IDMxLjY1NjggMjcuMTEwNyAzMS4xMzc5WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+' as const;\n\t}\n\n\tget chains() {\n\t\t// TODO: Extract chain from wallet:\n\t\treturn SUI_CHAINS;\n\t}\n\n\tget features(): StandardConnectFeature &\n\t\tStandardEventsFeature &\n\t\tSuiFeatures &\n\t\tQredoConnectFeature {\n\t\treturn {\n\t\t\t'standard:connect': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tconnect: this.#connect,\n\t\t\t},\n\t\t\t'standard:events': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\ton: this.#on,\n\t\t\t},\n\t\t\t'sui:signTransactionBlock': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignTransactionBlock: this.#signTransactionBlock,\n\t\t\t},\n\t\t\t'sui:signTransaction': {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignTransaction: this.#signTransaction,\n\t\t\t},\n\t\t\t'sui:signAndExecuteTransactionBlock': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignAndExecuteTransactionBlock: this.#signAndExecuteTransactionBlock,\n\t\t\t},\n\t\t\t'sui:signAndExecuteTransaction': {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignAndExecuteTransaction: this.#signAndExecuteTransaction,\n\t\t\t},\n\t\t\t'sui:signMessage': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignMessage: this.#signMessage,\n\t\t\t},\n\t\t\t'sui:signPersonalMessage': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n\t\t\t'qredo:connect': {\n\t\t\t\tversion: '0.0.1',\n\t\t\t\tqredoConnect: this.#qredoConnect,\n\t\t\t},\n\t\t};\n\t}\n\n\tget accounts() {\n\t\treturn this.#accounts;\n\t}\n\n\t#setAccounts(accounts: GetAccountResponse['accounts']) {\n\t\tthis.#accounts = accounts.map(\n\t\t\t({ address, publicKey, nickname }) =>\n\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\taddress,\n\t\t\t\t\tlabel: nickname || undefined,\n\t\t\t\t\tpublicKey: publicKey ? fromB64(publicKey) : new Uint8Array(),\n\t\t\t\t\tchains: this.#activeChain ? [this.#activeChain] : [],\n\t\t\t\t\tfeatures: ['sui:signAndExecuteTransaction'],\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor() {\n\t\tthis.#events = mitt();\n\t\tthis.#accounts = [];\n\t\tthis.#messagesStream = new WindowMessageStream('sui_in-page', 'sui_content-script');\n\t\tthis.#messagesStream.messages.subscribe(({ payload }) => {\n\t\t\tif (isWalletStatusChangePayload(payload)) {\n\t\t\t\tconst { network, accounts } = payload;\n\t\t\t\tif (network) {\n\t\t\t\t\tthis.#setActiveChain(network);\n\t\t\t\t\tif (!accounts) {\n\t\t\t\t\t\t// in case an accounts change exists skip updating chains of current accounts\n\t\t\t\t\t\t// accounts will be updated in the if block below\n\t\t\t\t\t\tthis.#accounts = this.#accounts.map(\n\t\t\t\t\t\t\t({ address, features, icon, label, publicKey }) =>\n\t\t\t\t\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\t\t\t\t\taddress,\n\t\t\t\t\t\t\t\t\tpublicKey,\n\t\t\t\t\t\t\t\t\tchains: this.#activeChain ? [this.#activeChain] : [],\n\t\t\t\t\t\t\t\t\tfeatures,\n\t\t\t\t\t\t\t\t\tlabel,\n\t\t\t\t\t\t\t\t\ticon,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (accounts) {\n\t\t\t\t\tthis.#setAccounts(accounts);\n\t\t\t\t}\n\t\t\t\tthis.#events.emit('change', { accounts: this.accounts });\n\t\t\t}\n\t\t});\n\t}\n\n\t#on: StandardEventsOnMethod = (event, listener) => {\n\t\tthis.#events.on(event, listener);\n\t\treturn () => this.#events.off(event, listener);\n\t};\n\n\t#connected = async () => {\n\t\tthis.#setActiveChain(await this.#getActiveNetwork());\n\t\tif (!(await this.#hasPermissions(['viewAccount']))) {\n\t\t\treturn;\n\t\t}\n\t\tconst accounts = await this.#getAccounts();\n\t\tthis.#setAccounts(accounts);\n\t\tif (this.#accounts.length) {\n\t\t\tthis.#events.emit('change', { accounts: this.accounts });\n\t\t}\n\t};\n\n\t#connect: StandardConnectMethod = async (input) => {\n\t\tif (!input?.silent) {\n\t\t\tawait mapToPromise(\n\t\t\t\tthis.#send<AcquirePermissionsRequest, AcquirePermissionsResponse>({\n\t\t\t\t\ttype: 'acquire-permissions-request',\n\t\t\t\t\tpermissions: ALL_PERMISSION_TYPES,\n\t\t\t\t}),\n\t\t\t\t(response) => response.result,\n\t\t\t);\n\t\t}\n\n\t\tawait this.#connected();\n\n\t\treturn { accounts: this.accounts };\n\t};\n\n\t#signTransactionBlock: SuiSignTransactionBlockMethod = async ({\n\t\ttransactionBlock,\n\t\taccount,\n\t\t...input\n\t}) => {\n\t\tif (!isTransaction(transactionBlock)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Unexpected transaction format found. Ensure that you are using the `Transaction` class.',\n\t\t\t);\n\t\t}\n\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignTransactionRequest, SignTransactionResponse>({\n\t\t\t\ttype: 'sign-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\t...input,\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t\ttransaction: transactionBlock.serialize(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => response.result,\n\t\t);\n\t};\n\n\t#signTransaction: SuiSignTransactionMethod = async ({ transaction, account, ...input }) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignTransactionRequest, SignTransactionResponse>({\n\t\t\t\ttype: 'sign-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\t...input,\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t\ttransaction: await transaction.toJSON(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\t({ result: { signature, transactionBlockBytes: bytes } }) => ({\n\t\t\t\tsignature,\n\t\t\t\tbytes,\n\t\t\t}),\n\t\t);\n\t};\n\n\t#signAndExecuteTransactionBlock: SuiSignAndExecuteTransactionBlockMethod = async (input) => {\n\t\tif (!isTransaction(input.transactionBlock)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Unexpected transaction format found. Ensure that you are using the `Transaction` class.',\n\t\t\t);\n\t\t}\n\n\t\treturn mapToPromise(\n\t\t\tthis.#send<ExecuteTransactionRequest, ExecuteTransactionResponse>({\n\t\t\t\ttype: 'execute-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\ttype: 'transaction',\n\t\t\t\t\tdata: input.transactionBlock.serialize(),\n\t\t\t\t\toptions: input.options,\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: input.account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => response.result,\n\t\t);\n\t};\n\n\t#signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = async (input) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<ExecuteTransactionRequest, ExecuteTransactionResponse>({\n\t\t\t\ttype: 'execute-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\ttype: 'transaction',\n\t\t\t\t\tdata: await input.transaction.toJSON(),\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tshowRawEffects: true,\n\t\t\t\t\t\tshowRawInput: true,\n\t\t\t\t\t},\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: input.account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t},\n\t\t\t}),\n\t\t\t({ result: { rawEffects, rawTransaction, digest } }) => {\n\t\t\t\tconst [\n\t\t\t\t\t{\n\t\t\t\t\t\ttxSignatures: [signature],\n\t\t\t\t\t\tintentMessage: { value: bcsTransaction },\n\t\t\t\t\t},\n\t\t\t\t] = bcs.SenderSignedData.parse(fromB64(rawTransaction!));\n\n\t\t\t\tconst bytes = bcs.TransactionData.serialize(bcsTransaction).toBase64();\n\n\t\t\t\treturn {\n\t\t\t\t\tdigest,\n\t\t\t\t\tsignature,\n\t\t\t\t\tbytes,\n\t\t\t\t\teffects: toB64(new Uint8Array(rawEffects!)),\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\t};\n\n\t#signMessage: SuiSignMessageMethod = async ({ message, account }) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignMessageRequest, SignMessageRequest>({\n\t\t\t\ttype: 'sign-message-request',\n\t\t\t\targs: {\n\t\t\t\t\tmessage: toB64(message),\n\t\t\t\t\taccountAddress: account.address,\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!response.return) {\n\t\t\t\t\tthrow new Error('Invalid sign message response');\n\t\t\t\t}\n\t\t\t\treturn response.return;\n\t\t\t},\n\t\t);\n\t};\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = async ({ message, account }) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignMessageRequest, SignMessageRequest>({\n\t\t\t\ttype: 'sign-message-request',\n\t\t\t\targs: {\n\t\t\t\t\tmessage: toB64(message),\n\t\t\t\t\taccountAddress: account.address,\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!response.return) {\n\t\t\t\t\tthrow new Error('Invalid sign message response');\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbytes: response.return.messageBytes,\n\t\t\t\t\tsignature: response.return.signature,\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\t};\n\n\t#hasPermissions(permissions: HasPermissionsRequest['permissions']) {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<HasPermissionsRequest, HasPermissionsResponse>({\n\t\t\t\ttype: 'has-permissions-request',\n\t\t\t\tpermissions: permissions,\n\t\t\t}),\n\t\t\t({ result }) => result,\n\t\t);\n\t}\n\n\t#getAccounts() {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<GetAccount, GetAccountResponse>({\n\t\t\t\ttype: 'get-account',\n\t\t\t}),\n\t\t\t(response) => response.accounts,\n\t\t);\n\t}\n\n\t#getActiveNetwork() {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<BasePayload, SetNetworkPayload>({\n\t\t\t\ttype: 'get-network',\n\t\t\t}),\n\t\t\t({ network }) => network,\n\t\t);\n\t}\n\n\t#setActiveChain({ env }: NetworkEnvType) {\n\t\tthis.#activeChain = env === API_ENV.customRPC ? 'sui:unknown' : API_ENV_TO_CHAIN[env];\n\t}\n\n\t#qredoConnect = async (input: QredoConnectInput): Promise<void> => {\n\t\tconst allowed = await mapToPromise(\n\t\t\tthis.#send<QredoConnectPayload<'connect'>, QredoConnectPayload<'connectResponse'>>({\n\t\t\t\ttype: 'qredo-connect',\n\t\t\t\tmethod: 'connect',\n\t\t\t\targs: { ...input },\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!isQredoConnectPayload(response, 'connectResponse')) {\n\t\t\t\t\tthrow new Error('Invalid qredo connect response');\n\t\t\t\t}\n\t\t\t\treturn response.args.allowed;\n\t\t\t},\n\t\t);\n\t\tif (!allowed) {\n\t\t\tthrow new Error('Rejected by user');\n\t\t}\n\t};\n\n\t#send<RequestPayload extends Payload, ResponsePayload extends Payload | void = void>(\n\t\tpayload: RequestPayload,\n\t\tresponseForID?: string,\n\t): Observable<ResponsePayload> {\n\t\tconst msg = createMessage(payload, responseForID);\n\t\tthis.#messagesStream.send(msg);\n\t\treturn this.#messagesStream.messages.pipe(\n\t\t\tfilter(({ id }) => id === msg.id),\n\t\t\tmap((msg) => msg.payload as ResponsePayload),\n\t\t);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { v4 as uuidV4 } from 'uuid';\n\nimport type { Payload } from './payloads/Payload';\n\nexport type Message = {\n\tid: string;\n\tpayload: Payload;\n};\n\nexport function createMessage<MsgPayload extends Payload>(\n\tpayload: MsgPayload,\n\tid?: string,\n): Message {\n\treturn {\n\t\tid: id || uuidV4(),\n\t\tpayload,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { registerWallet } from '@mysten/wallet-standard';\n\nimport { SuiWallet } from './WalletStandardInterface';\n\nregisterWallet(new SuiWallet());\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { type QredoSerializedUiAccount } from '_src/background/accounts/QredoAccount';\nimport { type UIQredoInfo, type UIQredoPendingRequest } from '_src/background/qredo/types';\nimport { type QredoConnectInput } from '_src/dapp-interface/WalletStandardInterface';\nimport { type Wallet } from '_src/shared/qredo-api';\n\nimport { isBasePayload, type BasePayload } from './BasePayload';\nimport { type Payload } from './Payload';\n\ntype Methods = {\n\tconnect: QredoConnectInput;\n\tconnectResponse: { allowed: boolean };\n\tgetPendingRequest: { requestID: string };\n\tgetPendingRequestResponse: { request: UIQredoPendingRequest | null };\n\tgetQredoInfo: {\n\t\tqredoID: string;\n\t\trefreshAccessToken: boolean;\n\t};\n\tgetQredoInfoResponse: { qredoInfo: UIQredoInfo | null };\n\tacceptQredoConnection: {\n\t\tqredoID: string;\n\t\taccounts: Wallet[];\n\t\tpassword: string;\n\t};\n\tacceptQredoConnectionResponse: { accounts: QredoSerializedUiAccount[] };\n\trejectQredoConnection: {\n\t\tqredoID: string;\n\t};\n};\n\nexport interface QredoConnectPayload<M extends keyof Methods> extends BasePayload {\n\ttype: 'qredo-connect';\n\tmethod: M;\n\targs: Methods[M];\n}\n\nexport function isQredoConnectPayload<M extends keyof Methods>(\n\tpayload: Payload,\n\tmethod: M,\n): payload is QredoConnectPayload<M> {\n\treturn (\n\t\tisBasePayload(payload) &&\n\t\tpayload.type === 'qredo-connect' &&\n\t\t'method' in payload &&\n\t\tpayload.method === method &&\n\t\t'args' in payload &&\n\t\t!!payload.args\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isBasePayload } from '_payloads';\nimport type { BasePayload, Payload } from '_payloads';\nimport type { NetworkEnvType } from '_src/shared/api-env';\n\nexport type WalletStatusChange = {\n\tnetwork?: NetworkEnvType;\n\taccounts?: { address: string; publicKey: string | null; nickname: string | null }[];\n};\n\nexport interface WalletStatusChangePayload extends BasePayload, WalletStatusChange {\n\ttype: 'wallet-status-changed';\n}\n\nexport function isWalletStatusChangePayload(\n\tpayload: Payload,\n): payload is WalletStatusChangePayload {\n\treturn isBasePayload(payload) && payload.type === 'wallet-status-changed';\n}\n"],"names":["_global","module","exports","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","basex","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","call","self","SENTRY_RELEASE","id","SENTRY_RELEASES","_RegisterWalletEvent_detail","RegisterWalletEvent","Event","constructor","callback","super","bubbles","cancelable","composed","set","receiver","state","value","kind","f","has","__classPrivateFieldSet","detail","__classPrivateFieldGet","type","preventDefault","stopImmediatePropagation","stopPropagation","WeakMap","randomUUID","crypto","bind","getRandomValues","rnds8","rng","byteToHex","push","toString","slice","options","buf","offset","rnds","random","arr","toLowerCase","unsafeStringify","extendStatics","b","setPrototypeOf","__proto__","p","__extends","String","__","create","__generator","thisArg","body","y","t","_","label","sent","trys","ops","next","verb","Symbol","iterator","v","op","done","pop","step","__values","s","m","__read","r","ar","error","__spreadArray","to","pack","arguments","l","concat","__await","SuppressedError","isArrayLike","isFunction","createErrorClass","createImpl","ctorFunc","instance","stack","UnsubscriptionError","_super","errors","message","map","err","join","name","arrRemove","item","index","indexOf","splice","Subscription","initialTeardown","closed","_parentage","_finalizers","unsubscribe","e_1","_a","e_2","_b","_parentage_1","_parentage_1_1","remove","e_1_1","return","initialFinalizer","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","e_2_1","add","teardown","_hasParent","_addParent","parent","includes","_removeParent","EMPTY","empty","EMPTY_SUBSCRIPTION","isSubscription","config","onUnhandledError","onStoppedNotification","Promise","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","setTimeout","handler","timeout","args","_i","delegate","apply","clearTimeout","handle","reportUnhandledError","noop","COMPLETE_NOTIFICATION","createNotification","context","errorContext","cb","isRoot","errorThrown","Subscriber","destination","_this","isStopped","EMPTY_OBSERVER","complete","SafeSubscriber","handleStoppedNotification","nextNotification","_next","_error","_complete","_bind","fn","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","notification","subscriber","observable","identity","Observable","subscribe","_subscribe","lift","operator","isObserver","_trySubscribe","sink","forEach","promiseCtor","getPromiseCtor","resolve","reject","pipe","operations","fns","input","reduce","prev","toPromise","innerFrom","isInteropObservable","obs","array","fromArrayLike","then","promise","asyncIterator","isAsyncIterable","fromAsyncIterable","isIterable","iterable","iterable_1","iterable_1_1","getReader","isReadableStreamLike","readableStream","_arguments","generator","q","resume","fulfill","settle","shift","__asyncGenerator","reader","read","releaseLock","readableStreamLikeToAsyncGenerator","createInvalidObservableTypeError","asyncIterable","asyncIterable_1","asyncIterable_1_1","P","__asyncValues","fulfilled","rejected","result","process","catch","operate","init","hasLift","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","closed_1","project","mergeMap","resultSelector","concurrent","Infinity","ii","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","active","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","_loop_1","bufferedValue","mergeInternals","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","callOrApply","addEventListener","removeEventListener","isEventTarget","methodName","addListener","removeListener","isNodeStyleEventEmitter","toCommonHandlerRegistry","on","off","isJQueryStyleEventEmitter","subTarget","filter","predicate","ObjectUnsubscribedError","Subject","currentObservers","observers","hasError","thrownError","subject","AnonymousSubject","_throwIfClosed","_c","configurable","_checkFinalizedStatuses","_innerSubscribe","asObservable","handleReset","reset","onSubscriber","WindowMessageStream","_name","_target","messages","data","payload","connector","resetOnError","resetOnComplete","_d","resetOnRefCountZero","wrapperSource","connection","resetConnection","refCount","hasCompleted","hasErrored","cancelReset","resetAndUnsubscribe","conn","dest","share","send","msg","postMessage","ALL_PERMISSION_TYPES","API_ENV","isBasePayload","local","testNet","devNet","mainnet","customRPC","toB58","base64String","atob","char","CHUNK_SIZE","toB64","bytes","btoa","fromCharCode","output","chunk","hexStr","normalized","startsWith","padded","intArr","match","byte","parseInt","toHEX","padStart","ulebEncode","num","len","BcsReader","bytePosition","dataView","DataView","read8","getUint8","read16","getUint16","read32","getUint32","read64","value1","BigInt","read128","read256","readBytes","start","readULEB","total","ulebDecode","readVec","BcsWriter","initialSize","maxSize","allocateSize","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","write8","setUint8","Number","write16","setUint16","write32","setUint32","write64","toLittleEndian","el","write128","write256","writeULEB","writeVec","vector","toBytes","encoding","encodeStr","bigint","BcsType","serializedSize","write","serialize","writer","validate","SerializedBcs","parse","fromHex","hex","fromBase58","b64","fromBase64","transform","SERIALIZED_BCS_BRAND","for","schema","toHex","toBase64","toBase58","fixedSizeBcsType","uIntBcsType","readMethod","writeMethod","maxValue","bigUIntBcsType","val","u8","u16","u32","u64","u128","u256","bool","uleb128","dynamicSizeBcsType","fromBytes","stringLikeBcsType","TextEncoder","TextDecoder","fixedArray","option","enum","None","Some","$kind","tuple","types","values","struct","fields","canonicalOrder","entries","field","hasOwn","optionName","optionType","keys","k","variant","keyType","valueType","Map","lazy","lazyType","getType","lazyBcsType","SUI_ADDRESS_LENGTH","isValidSuiAddress","test","isHex","getHexByteLength","forceAdd0x","address","normalizeSuiObjectId","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","static","normalizeAddress","signer","vectorMatch","parseFromStr","structMatch","typeParams","parseStructTypeArgs","genericSeparators","left","right","tok","word","nestedAngleBrackets","trim","tag","tagToString","Address","ObjectDigest","SuiObjectRef","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","ObjectArg","ImmOrOwnedObject","SharedObject","Receiving","CallArg","Pure","InnerTypeTag","StructTag","TypeTag","typeTag","GasCoin","Input","Result","NestedResult","ProgrammableMoveCall","package","function","typeArguments","Command","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","sources","Publish","modules","dependencies","MakeMoveVec","elements","Upgrade","ticket","ProgrammableTransaction","inputs","commands","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","Epoch","GasData","payment","owner","price","budget","TransactionDataV1","sender","gasData","expiration","TransactionData","V1","IntentScope","TransactionEffects","CheckpointSummary","PersonalMessage","IntentVersion","V0","AppId","Sui","Intent","scope","appId","IntentMessage","T","intent","CompressedSignature","ED25519","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","SenderSignedTransaction","intentMessage","txSignatures","SenderSignedData","PackageUpgradeError","UnableToFetchPackage","packageId","NotAPackage","IncompatibleUpgrade","DigestDoesNotMatch","UnknownUpgradePolicy","policy","PackageIDDoesNotMatch","ticketId","ModuleId","MoveLocation","instruction","functionName","CommandArgumentError","TypeMismatch","InvalidBCSBytes","InvalidUsageOfPureArg","InvalidArgumentToPrivateEntryFunction","IndexOutOfBounds","idx","SecondaryIndexOutOfBounds","resultIdx","secondaryIdx","InvalidResultArity","InvalidGasCoinUsage","InvalidValueUsage","InvalidObjectByValue","InvalidObjectByMutRef","SharedObjectOperationNotAllowed","TypeArgumentError","TypeNotFound","ConstraintNotSatisfied","ExecutionFailureStatus","InsufficientGas","InvalidGasObject","InvariantViolation","FeatureNotYetSupported","MoveObjectTooBig","objectSize","maxObjectSize","MovePackageTooBig","CircularObjectOwnership","object","InsufficientCoinBalance","CoinBalanceOverflow","PublishErrorNonZeroAddress","SuiMoveVerificationError","MovePrimitiveRuntimeError","MoveAbort","VMVerificationOrDeserializationError","VMInvariantViolation","FunctionNotFound","ArityMismatch","TypeArityMismatch","NonEntryFunctionInvoked","argIdx","argumentIdx","UnusedValueWithoutDrop","InvalidPublicFunctionReturnType","InvalidTransferObject","EffectsTooLarge","currentSize","PublishUpgradeMissingDependency","PublishUpgradeDependencyDowngrade","upgradeError","WrittenObjectsTooLarge","CertificateDenied","SuiMoveVerificationTimedout","InputObjectDeleted","ExecutionStatus","Success","Failed","command","GasCostSummary","computationCost","storageCost","storageRebate","nonRefundableStorageFee","Owner","AddressOwner","ObjectOwner","Shared","Immutable","TransactionEffectsV1","status","executedEpoch","gasUsed","modifiedAtVersions","sharedObjects","transactionDigest","created","mutated","unwrapped","deleted","unwrappedThenDeleted","wrapped","gasObject","eventsDigest","VersionDigest","ObjectIn","NotExist","Exist","ObjectOut","ObjectWrite","PackageWrite","IDOperation","Created","Deleted","EffectsObjectChange","inputState","outputState","idOperation","UnchangedSharedKind","ReadOnlyRoot","MutateDeleted","ReadDeleted","TransactionEffectsV2","gasObjectIndex","lamportVersion","changedObjects","unchangedSharedObjects","auxDataDigest","V2","suiBcs","U8","U16","U32","U64","U128","U256","ULEB128","Bool","Argument","TransactionExpiration","ValiError","issues","errorMessage","actionIssue","validation","requirement","path","actionOutput","defaultArgs","arg1","arg2","parseResult","typed","restAndDefaultArgs","arg3","error2","pipe2","pipeIssue","info","issue","reason","origin","abortEarly","abortPipeEarly","skipPipe","pipeInfo","pipeResult","parseInfo","action","_parse","issueInfo","schemaIssue","getDefault","default","async","value2","pathItem","unshift","literal","literal2","nullable","default_","override","nullish","number","isNaN","arg4","rest","cachedEntries","optional","BLOCKED_KEYS","record","message2","recordArgs","inputKey","inputValue","keyResult","valueResult","recursive","union","unknown","custom","integer","isInteger","safeEnum","SuiAddress","ObjectID","BCSBytes","JsonU64","items","OpenMoveTypeSignatureBody","datatype","typeParameters","typeParameter","OpenMoveTypeSignature","ref","_argumentTypes","$Intent","UnresolvedPure","UnresolvedObject","SUI_FRAMEWORK_ADDRESS","TRANSACTION_BRAND","isTransaction","Transaction","serialized","tx","TransactionDataBuilder","fromKindBytes","fromB64","transaction","newTransaction","getData","restore","JSON","addSerializationPlugin","addBuildPlugin","addIntentResolver","resolver","setSender","setSenderIfNotSet","setExpiration","setGasPrice","gasConfig","setGasBudget","setGasOwner","setGasPayment","payments","ObjectRef","blockData","serializeV1TransactionData","snapshot","pure","createPure","isSerializedBcs","addInput","is","NormalizedCallArg","Inputs","gas","getIdFromCallArg","inserted","find","normalizeSuiAddress","objectRef","receivingRef","ReceivingRef","sharedObjectRef","nestedResults","nestedResultFor","resultIndex","Proxy","property","Reflect","createTransactionResult","splitCoins","Commands","amount","mergeCoins","src","publish","upgrade","moveCall","arg","transferObjects","makeMoveVec","stringify","prepareForSerialization","SerializedTransactionDataV2","_key","buildOptions","build","signTransaction","onlyTransactionKind","getDigest","intents","Set","steps","supportedIntents","SUI_DEVNET_CHAIN","SUI_TESTNET_CHAIN","SUI_LOCALNET_CHAIN","SUI_MAINNET_CHAIN","SUI_CHAINS","_ReadonlyWalletAccount_address","_ReadonlyWalletAccount_publicKey","_ReadonlyWalletAccount_chains","_ReadonlyWalletAccount_features","_ReadonlyWalletAccount_label","_ReadonlyWalletAccount_icon","ReadonlyWalletAccount","account","freeze","publicKey","chains","features","icon","EmptyError","mapToPromise","stream","seen","response","_value","_hasValue","API_ENV_TO_CHAIN","accounts","nickname","permissions","network","env","responseForID","createMessage","wallet","register","dispatchEvent","console","api","registerWallet","connect","signTransactionBlock","signAndExecuteTransactionBlock","signAndExecuteTransaction","signMessage","signPersonalMessage","qredoConnect","event","listener","emit","silent","transactionBlock","toJSON","signature","transactionBlockBytes","showRawEffects","showRawInput","rawEffects","rawTransaction","bcsTransaction","effects","accountAddress","messageBytes","method","allowed","all","isWalletStatusChangePayload"],"sourceRoot":""}